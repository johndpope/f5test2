#!/usr/bin/env python
'''
Created on Apr 17, 2013

@author: jono
'''
from __future__ import absolute_import
from f5test.macros.base import Macro
from f5test.interfaces.ssh import SSHInterface
from f5test.interfaces.config import ConfigInterface
from f5test.interfaces.rest.irack import IrackInterface
from f5test.interfaces.rest.emapi import EmapiInterface
from f5test.interfaces.rest.emapi.objects import EasySetup
from f5test.macros.tmosconf.scaffolding import Partition, Mirror, enumerate_stamps
from f5test.macros.tmosconf.base import (SystemConfig, NetworkConfig,
                                         LTMConfig)
from f5test.macros.tmosconf.net import SelfIP
import f5test.commands.shell as SCMD
from f5test.utils.net import ip4to6
from f5test.utils.wait import wait_args
from f5test.macros.webcert import WebCert
from f5test.macros.keyswap import KeySwap
from f5test.base import Options as O
from f5test.defaults import ROOT_USERNAME, ROOT_PASSWORD
from netaddr import IPAddress, IPNetwork
from f5test.commands.shell import WIPE_STORAGE
import logging
import re
import sys
import os
import csv

__version__ = 2.0

DEFAULT_NODES = 10
DEFAULT_NODE_START = '10.10.0.50'
DEFAULT_POOLS = 60
DEFAULT_MEMBERS = 1
DEFAULT_VIPS = 8
DEFAULT_PARTITIONS = 0
DEFAULT_ROOT_USERNAME = ROOT_USERNAME
DEFAULT_ROOT_PASSWORD = ROOT_PASSWORD
DEFAULT_TIMEOUT = 180
DEFAULT_SELF_PREFIX = 16
SCF_FILENAME = '/tmp/config.scf'
DNS_SERVERS = ['172.27.1.1']
DNS_SUFFIXES = ['mgmt.pdsea.f5net.com', 'f5net.com']
NTP_SERVERS = ['ntp.f5net.com']
OUR_ADMIN_USERNAME = OUR_ADMIN_PASSWORD = 'a'
HEADER = """# Autogenerated by tmosconf %s\n\n""" % __version__
LOG = logging.getLogger(__name__)

# All known 172.27.XXX.0/24 subnets tangent to the VLAN1011.
# This is used for VS address allocation.
SUBNET_MAP = dict([(y, x) for x, y in enumerate([])])


class ConfigPlacer(Macro):
    SystemConfig = SystemConfig
    NetworkConfig = NetworkConfig
    LTMConfig = LTMConfig

    def __init__(self, options, address=None, *args, **kwargs):
        self.context = O()
        self.options = O(options)

        self.options.setifnone('node_count', DEFAULT_NODES)
        self.options.setifnone('pool_count', DEFAULT_POOLS)
        self.options.setifnone('pool_members', DEFAULT_MEMBERS)
        self.options.setifnone('vip_count', DEFAULT_VIPS)
        self.options.setifnone('node_start', DEFAULT_NODE_START)
        self.options.setifnone('partitions', DEFAULT_PARTITIONS)
        self.options.setifnone('timeout', DEFAULT_TIMEOUT)

        if self.options.device:
            self.device = ConfigInterface().get_device(options.device)
            self.address = self.device.address
        else:
            self.device = None
            self.address = address
            self.options.setifnone('username', DEFAULT_ROOT_USERNAME)
            self.options.setifnone('password', DEFAULT_ROOT_PASSWORD)

        # can.* shortcuts to check for certain features based on the version
        self.can = O()

        def can_tmsh(v):
            return (v.product.is_bigip and v >= 'bigip 11.0.0' or
                    v.product.is_em and v >= 'em 2.0.0' or
                    v.product.is_bigiq)
        self.can.tmsh = can_tmsh

        def can_provision(v):
            return (v.product.is_bigip and v >= 'bigip 10.0.1' or
                    v.product.is_em and v >= 'em 2.0.0' or
                    v.product.is_bigiq)
        self.can.provision = can_provision

        def can_lvm(sshifc):
            return not sshifc('/usr/lib/install/lvmtest').status
        self.can.lvm = can_lvm

        self.has = O()

        def has_asm(s):
            return bool(SCMD.tmsh.get_provision(ifc=s).asm)
        self.has.asm = has_asm

        def has_lvm(s):
            return not s('/usr/lib/install/lvmtest').status
        self.has.lvm = has_lvm

        super(ConfigPlacer, self).__init__(*args, **kwargs)

    def csv_provider(self, mgmtip):
        """
        Get the static data for a device with a given mgmtip from a CSV file.
        """
        venv_path = os.environ['VIRTUAL_ENV']
        csv_location = venv_path + self.options.csv

        data = O()
        with open(csv_location, 'rb') as csvfile:
            reader = csv.DictReader(csvfile)

            device_row = None
            for row in reader:
                # Clean up whitespaces
                row = {x.strip(): y.strip() for x, y in row.iteritems()}
                if IPAddress(mgmtip) == IPNetwork(row['mgmtip']).ip:
                    device_row = row
                    break

            if device_row:
                if 'hostname' in device_row and device_row['hostname']:
                    data.hostname = device_row['hostname']

                data.licenses = {}
                if 'reg_key' in device_row and device_row['reg_key']:
                    data.licenses.reg_key = [device_row['reg_key']]

                data.selfip = {}
                if 'internal' in device_row and device_row['internal']:
                    data.selfip.internal = IPNetwork(device_row['internal'])
                if 'external' in device_row and device_row['external']:
                    data.selfip.external = IPNetwork(device_row['external'])

                if 'gateway' in device_row and device_row['gateway']:
                    data.gateway = IPAddress(device_row['gateway'])

                data.mgmtip = IPNetwork(device_row['mgmtip'])

            else:
                LOG.warning("No devices with mgmtip=%s found in CSV." % mgmtip)

            LOG.debug(data)
            return data

    def irack_provider(self, address, username, apikey, mgmtip, timeout=120):
        """Get the static data for a device with a given mgmtip from iRack."""
        data = O()
        with IrackInterface(address=address,
                            timeout=timeout,
                            username=username,
                            password=apikey, proto='http') as irack:
            params = dict(address_set__address__in=mgmtip, address_set__type=4)
            # Locate the static bag for the F5Asset with mgmtip
            ret = irack.api.staticbag.filter(asset__type=1, **params)

            if ret.data.meta.total_count == 0:
                LOG.warning("No devices with mgmtip=%s found in iRack." % mgmtip)
                return data
            if ret.data.meta.total_count > 1:
                raise ValueError("More than one device with mgmtip=%s found in iRack." % mgmtip)

            bag = ret.data.objects[0]
            bagid = bag['id']

            # Get the hostname
            ret = irack.api.staticsystem.filter(bag=bagid)
            assert ret.data.meta.total_count == 1, "No StaticSystem entries for bagid=%s" % bagid
            data.hostname = ret.data.objects[0].hostname

            # Get all reg_keys
            ret = irack.api.staticlicense.filter(bag=bagid)
            assert ret.data.meta.total_count >= 1, "No StaticLicense entries for bagid=%s" % bagid
            data.licenses = {}
            data.licenses.reg_key = [x.reg_key for x in ret.data.objects]

            # Get all VLAN -> self IPs pairs
            ret = irack.api.staticaddress.filter(bag=bagid, type=1)
            data.selfip = {}
            for o in ret.data.objects:
                vlan = o.vlan.split('/')[-1]
                # TODO: IPv6 support...someday?
                if IPAddress(o.address).version == 4 \
                   and not int(o.floating):
                    data.selfip[vlan] = IPNetwork("{0.address}/{0.netmask}".format(o))

            # Get all mgmt ips
            ret = irack.api.staticaddress.filter(bag=bagid, type=0)
            assert ret.data.meta.total_count >= 1, "No StaticAddress entries for bagid=%s" % bagid
            data.mgmtip = {}
            for o in ret.data.objects:
                if IPAddress(o.address).version == 4:
                    data.mgmtip = IPNetwork("{0.address}/{0.netmask}".format(o))

            # GW
            ret = irack.api.staticaddress.filter(bag=bagid, type=3)
            assert ret.data.meta.total_count >= 1, "No StaticAddress entries for bagid=%s" % bagid
            for o in ret.data.objects:
                if IPAddress(o.address).version == 4:
                    data.gateway = IPAddress(o.address)

        LOG.debug(data)
        return data

    def make_context(self):
        ctx = self.context
        version_data = SCMD.ssh.get_version(ifc=self.sshifc)
        ctx.version = version_data
        ctx.project = SCMD.ssh.parse_keyvalue_file('/VERSION',
                                                   ifc=self.sshifc).get('project')
        ctx.platform = SCMD.ssh.get_platform(ifc=self.sshifc)['platform']
        ctx.is_cluster = SCMD.ssh.is_cluster(ifc=self.sshifc)
        ctx.is_vcmp = ctx.platform == 'Z101'
        ctx.status = SCMD.ssh.GetPrompt(ifc=self.sshifc)\
            .run_wait(lambda x: x not in ('INOPERATIVE',),
                      progress_cb=lambda x: 'Still %s...' % x,
                      timeout_message="Timeout ({0}s) waiting for an non-inoperative prompt.",
                      timeout=self.options.timeout)

        if self.can.provision(ctx.version):
            ctx.provision = {}
            modules = SCMD.tmsh.get_provision(ifc=self.sshifc)
            for k, v in modules.iteritems():
                if v:
                    ctx.provision[k] = v['level']

        try:
            tokens = SCMD.ssh.parse_license(ifc=self.sshifc, tokens_only=True)
            ctx.modules = dict([(k[4:], v) for (k, v) in tokens.items()
                                if k.startswith('mod_')])

            ctx.features = dict([(k, v) for (k, v) in tokens.items()
                                if not k.startswith('mod_')])
        except SCMD.ssh.LicenseParsingError as e:
            ctx.modules = {}
            ctx.features = {}
            LOG.debug(e)
            LOG.warning('License file parsing failed. Harmless if this is a clean box.')

        LOG.info('Version: {0.product.to_tmos} {0.version} {0.build}'.format(ctx.version))
        LOG.info('Platform: %s', ctx.platform)
        LOG.info('Licensed modules: %s', ', '.join(sorted(ctx.modules)))
        if self.can.provision(ctx.version):
            LOG.info('Current provisioning: %s', ', '.join(sorted(ctx.provision)))
        return ctx

    def prep(self):
        self.sshifc = SSHInterface(device=self.device,
                                   address=self.address,
                                   username=self.options.username,
                                   password=self.options.password,
                                   timeout=self.options.timeout,
                                   port=self.options.ssh_port)
        self.sshifc.open()

    def set_networking(self, o):
        ctx = self.context
        if self.options.mgmtip:
            o.mgmtip = IPNetwork(self.options.mgmtip)
            if o.mgmtip.prefixlen == 32:
                o.mgmtip.prefixlen = 24
                LOG.warning('Assuming /24 to the management IP.')
        elif ctx.is_cluster:
            ret = SCMD.tmsh.list('sys cluster default', ifc=self.sshifc)
            o.mgmtip = IPNetwork(ret['sys cluster default']['address'])
            ret = SCMD.tmsh.list('sys management-route', ifc=self.sshifc)
            # Sometimes it's defined as "default" some other times it's "0.0.0.0"
            if ret:
                o.gateway = IPAddress(ret.values()[0]['gateway'])
        else:
            # Try to find the existing IP configuration on management interface.
            ret = self.sshifc("ethconfig --getcurrent")
            bits = ret.stdout.split()
            o.mgmtip = IPNetwork("{0[0]}/{0[1]}".format(bits))
            o.gateway = IPAddress(bits[2])

        # If None or IPAddress('0.0.0.0')
        if not o.gateway:
            o.gateway = IPAddress(self.options.mgmtgw) if self.options.mgmtgw \
                else o.mgmtip.broadcast - 1

        # Preserve the DHCP flag for the management interface
        if self.can.tmsh(ctx.version):
            ret = SCMD.tmsh.list('sys db dhclient.mgmt', ifc=self.sshifc)
            o.dhcp = ret['sys db dhclient.mgmt']['value'] == 'enable'

    def set_provisioning(self, o):
        ctx = self.context
        if not self.can.provision(ctx.version):
            LOG.info('Provision not supported on the target')
            return

        o.provision = {}
        provision = []
        if self.options.get('provision'):
            for prov in self.options['provision'].split(','):
                if prov:
                    bits = prov.lower().split(':', 1)
                    if len(bits) > 1:
                        module, level = bits
                        assert level in ('minimum', 'nominal', 'dedicated')
                    else:
                        module = bits[0].strip()
                        level = 'nominal' if module == 'ltm' else 'minimum'
                    provision.append((module, level))

        if provision:
            v = ctx.version
            for module, level in provision:
                if module == 'afm' and not (v.product.is_bigip and v >= 'bigip 11.3.0'):
                    LOG.warning('AFM cannot be provisioned on this target.')
                    continue
                o.provision[module] = level
        else:
            # Preserve provisioning.
            modules = SCMD.tmsh.get_provision(ifc=self.sshifc)
            for module, level_kv in modules.iteritems():
                if level_kv:
                    level = level_kv['level']
                    o.provision[module] = level

    def set_users(self, o):
        ctx = self.context
        v = ctx.version
        o.users = {}

        o.users[OUR_ADMIN_USERNAME] = 'admin'
        if v.product.is_bigip or v.product.is_em:
            o.users.g = 'guest'
            o.users.o = 'operator'
            o.users.ae = 'application-editor'
            o.users.m = 'manager'
            o.users.um = 'user-manager'
            o.users.ra = 'resource-admin'

        if v.product.is_bigip and v >= 'bigip 11.3.0':
            o.users.cm = 'certificate-manager'
            o.users.im = 'irule-manager'
            o.users.au = 'auditor'
            o.users.asa = 'web-application-security-administrator'
            o.users.ase = 'web-application-security-editor'
            o.users.fm = 'firewall-manager'

        if v.product.is_bigiq:
            o.users.g = 'guest'
            o.users.fw = 'firewall-manager'

    def set_vlans(self, o):
        ctx = self.context
        lacp = self.options.trunks_lacp

        if ctx.platform.startswith('A'):
            o.trunks = {}
            eth1 = 'internal'  # Trunk names
            eth2 = 'external'
        elif ctx.platform.startswith('Z'):
            # VEs can may have a variable number of TMM interfaces.
            # Adjusting accordingly.
            ret = SCMD.tmsh.list('net interface', ifc=self.sshifc)
            interfaces = sorted([x.split()[2] for x in ret.keys()
                                 if x.split()[2] != 'mgmt'])
            eth1, eth2 = (interfaces + [None, None])[:2]
        else:
            eth1 = '1.1'
            eth2 = '1.2'

        o.vlans = {}
        if ctx.is_vcmp:
            # No trunks. They will be automatically generated on VCMP guests.
            eth1 = eth2 = None
            ret = SCMD.tmsh.list('net vlan', ifc=self.sshifc)
            for key, obj in ret.items():
                s = Mirror(key, obj)
                o.vlans[s.name] = s

        if ctx.platform == 'A100':
            o.trunks.internal = O(interfaces=['1/2.1', '2/2.1', '3/2.1', '4/2.1'], lacp=lacp)
            o.trunks.external = O(interfaces=['1/2.2', '2/2.2', '3/2.2', '4/2.2'], lacp=lacp)
        elif ctx.platform in ('A107', 'A109', 'A111'):
            o.trunks.internal = O(interfaces=['1/1.1', '2/1.1', '3/1.1', '4/1.1'], lacp=lacp)
            o.trunks.external = O(interfaces=['1/1.2', '2/1.2', '3/1.2', '4/1.2'], lacp=lacp)
        elif ctx.platform == 'A108':
            o.trunks.internal = O(interfaces=['1/1.1', '2/1.1', '3/1.1', '4/1.1', '5/1.1', '6/1.1', '7/1.1', '8/1.1'], lacp=lacp)
            o.trunks.external = O(interfaces=['1/1.2', '2/1.2', '3/1.2', '4/1.2', '5/1.2', '6/1.2', '7/1.2', '8/1.2'], lacp=lacp)

        def parse_vlan_options(kind):
            specs = O(tagged=[], untagged=[])
            if kind == 'internal':
                tags = self.options.vlan_internal
                if not tags:
                    specs.untagged.append(eth1)
            if kind == 'external':
                tags = self.options.vlan_external
                if not tags:
                    specs.untagged.append(eth2)

            if tags:
                for tag in re.split('\s+', tags):
                    key, value = tag.split('=')
                    if key == 'tag':
                        specs.tag = value
                    else:
                        specs[key].append(value)
            return specs

        if eth1:
            o.vlans.internal = O(**parse_vlan_options('internal'))
        if eth2:
            o.vlans.external = O(**parse_vlan_options('external'))

#     def fix_cmi(self):
#         """
#         The main goal of this method is to empty all device groups, otherwise
#         the config load will fail. There should be a better way of doing this.
#         """
#         ctx = self.context
#         if self.can.tmsh(ctx.version):
#             LOG.debug('Emptying CM device groups...')
#             ret = SCMD.tmsh.list('cm device-group', ifc=self.sshifc)
#             for key, value in ret.iteritems():
#                 devices = value.get('devices')
#                 if devices:
#                     ret = self.sshifc('tmsh modify %s devices delete { %s }' %
#                                       (key, ' '.join(devices.keys())))
#                     if ret.status:
#                         LOG.warning(ret)

    def dump(self, tree, ctx, func=None):
        f = sys.stdout  # @UndefinedVariable
        LOG.info('Rendering configuration file...')
        f.write(HEADER)
        tree.render(stream=f, func=func)

    def load(self, tree, ctx, func=None):
        with self.sshifc.api.sftp().open(SCF_FILENAME, 'w') as f:
            LOG.info('Rendering configuration file...')
            f.write(HEADER)
            tree.render(stream=f, func=func)

        if self.can.tmsh(ctx.version):
            if self.options.verify:
                LOG.info('Verifying configuration...')
                ret = self.sshifc('tmsh load sys config file %s verify' % SCF_FILENAME)
                LOG.info(ret.stdout)
            else:
                LOG.info('Loading configuration...')
                SCMD.ssh.generic('tmsh load sys config file %s' % SCF_FILENAME, ifc=self.sshifc)
        else:
            LOG.info('Loading configuration...')
            SCMD.ssh.generic('b import  %s' % SCF_FILENAME, ifc=self.sshifc)

    def save(self, ctx):
        LOG.info('Saving configuration...')
        if self.can.tmsh(ctx.version):
            SCMD.ssh.generic('tmsh save sys config partitions all', ifc=self.sshifc)
        else:
            SCMD.ssh.generic('b save all', ifc=self.sshifc)

    def reset_trust(self):
        v = self.context.version
        if v.product.is_bigiq and v > 'bigiq 4.0':
            return

        if self.can.tmsh(v):
            LOG.info('Resetting trust...')
            SCMD.ssh.Generic('tmsh delete cm trust-domain all', ifc=self.sshifc).\
                run_wait(lambda x: x.status == 0,
                         progress_cb=lambda x: 'delete trust-domain retry...',
                         timeout=self.options.timeout)

    def ready_wait(self):
        ctx = self.context
        if self.options.get('dry_run'):
            return

        LOG.info('Waiting for reconfiguration...')
        timeout = self.options.timeout
        SCMD.ssh.FileExists('/var/run/mprov.pid', ifc=self.sshifc)\
            .run_wait(lambda x: x is False,
                      progress_cb=lambda x: 'mprov still running...',
                      timeout=timeout)
        if (self.can.provision(ctx.version) and self.has.asm(self.sshifc) and
                self.has.lvm(self.sshifc)):
            SCMD.ssh.FileExists('/var/lib/mysql/.moved.to.asmdbvol', ifc=self.sshifc)\
                .run_wait(lambda x: x,
                          progress_cb=lambda x: 'ASWADB still not there...',
                          timeout=timeout)
        # Wait for ASM config server to come up.
        if self.can.provision(ctx.version) and self.has.asm(self.sshifc):
            LOG.info('Waiting for ASM config server to come up...')
            SCMD.ssh.Generic(r'netstat -anp|grep -P ":9781\s+(0\.0\.0\.0|::):\*\s+LISTEN"|wc -l',
                             ifc=self.sshifc).run_wait(lambda x: int(x.stdout),
                                                       progress_cb=lambda x: 'ASM cfg server not up...',
                                                       timeout=timeout)

        LOG.info('Waiting for Active prompt...')
        s = SCMD.ssh.GetPrompt(ifc=self.sshifc)\
            .run_wait(lambda x: x in ('Active', 'Standby', 'ForcedOffline',
                                      'RESTART DAEMONS', 'REBOOT REQUIRED'),
                      progress_cb=lambda x: 'Still not active (%s)...' % x,
                      timeout_message="Timeout ({0}s) waiting for an 'Active' prompt.",
                      timeout=timeout)

        if s == 'RESTART DAEMONS':
            LOG.info('Restarting daemons...')
            self.call('bigstart restart')
            SCMD.ssh.GetPrompt(ifc=self.sshifc)\
                .run_wait(lambda x: x in ('Active', 'Standby', 'ForcedOffline'),
                          progress_cb=lambda x: 'Still not active (%s)...' % x,
                          timeout=timeout)
        elif s == 'REBOOT REQUIRED':
            LOG.warn('A manual reboot is required.')

        if SCMD.ssh.file_exists('/var/run/grub.conf.lock', ifc=self.sshifc):
            self.ssh.api.remove('/var/run/grub.conf.lock')

    def ssh_key_exchange(self):
        if self.options.get('no_sshkey'):
            return

        o = O()
        o.device = self.device
        o.username = self.options.username
        o.password = self.options.password
        o.port = self.options.ssh_port
        cs = KeySwap(o, address=self.address)
        cs.run()

    def ssl_signedcert_install(self, hostname):
        # BUG: Sometimes user 'a' role gets downgraded to 'guest' at this point.
        #      It's still unclear why this happens.
        if self.context.version >= 'bigip 11.6' or self.context.version >= 'bigiq 4.6':
            SCMD.ssh.generic('tmsh modify auth user %s partition-access modify  {all-partitions {role admin}}' % OUR_ADMIN_USERNAME,
                             ifc=self.sshifc)
        else:
            SCMD.ssh.generic('tmsh modify auth user %s role admin' % OUR_ADMIN_USERNAME,
                             ifc=self.sshifc)
        o = O()
        o.admin_username = OUR_ADMIN_USERNAME
        o.root_username = self.options.username
        o.ssh_port = self.options.ssh_port
        o.ssl_port = self.options.ssl_port
        o.verbose = self.options.verbose
        o.timeout = self.options.timeout
        LOG.info('Pushing the key/certificate pair')

        # The special a:a admin user is used here. It should be included in the
        # remote_config yaml config in the users.administrator section.
        o.admin_password = OUR_ADMIN_PASSWORD
        o.root_password = self.options.password

        if hostname:
            o.alias = [hostname]
        cs = WebCert(o, address=self.address)
        cs.run()

    def bigiq_special_selfip_handling(self, tree, ctx):
        "Because the use of tmsh has become frown upon starting with 4.2"
        v = ctx.version
        if v.product.is_bigiq and v >= 'bigiq 4.2.0':
            # XXX: Because sometimes user 'a' set via tmsh is not picked up.
            self.call('bigstart restart restjavad')
            with EmapiInterface(username=OUR_ADMIN_USERNAME,
                                password=OUR_ADMIN_PASSWORD,
                                port=self.options.ssl_port,
                                address=self.address) as rstifc:
                payload = O(selfIpAddresses=[])
                for self_ip in enumerate_stamps(tree, SelfIP, include_common=False):
                    # XXX: BIGIQ 4.2 API only supports untagged.
                    for iface in self_ip.vlan.untagged:
                        payload.selfIpAddresses.append(O(address=str(self_ip.address),
                                                         vlan=self_ip.vlan.name,
                                                         iface=iface))
                LOG.debug('EasySetup payload: %s', payload)
                wait_args(rstifc.api.patch, func_args=(EasySetup.URI, payload),
                          timeout=180, interval=5,
                          timeout_message="Can't patch selfIPs ready after {0}s")

#     def bigiq_special_selfip_handling(self, tree, ctx):
#         "Because the use of tmsh has become frown upon starting with 4.2"
#         v = ctx.version
#         if v.product.is_bigiq and v >= 'bigiq 4.2.0':
#             # XXX: Because sometimes user 'a' set via tmsh is not picked up.
#             self.call('bigstart restart restjavad')
#             with EmapiInterface(username=OUR_ADMIN_USERNAME,
#                                 password=OUR_ADMIN_PASSWORD,
#                                 port=self.options.ssl_port,
#                                 address=self.address) as rstifc:
#                 LOG.info('Waiting for restjavad to come up...')
#                 vlans = wait_args(rstifc.api.get, func_args=(NetworkVlan.URI,),
#                                   timeout=60, interval=5,
#                                   timeout_message="Can't get VLANs in {0}s")
#                 vlans_by_name = dict(((x.name, x) for x in vlans['items']))
#                 for self_ip in enumerate_stamps(tree, SelfIP, include_common=False):
#                     # XXX: BIGIQ 4.2 API only supports untagged.
#                     # And only one interface per VLAN.
#                     payload = NetworkSelfip()
#                     payload.name = self_ip.name
#                     payload.address = str(self_ip.address)
#                     payload.vlanReference = vlans_by_name[self_ip.vlan.name]
#                     rstifc.api.post(NetworkSelfip.URI, payload=payload)

    def calculate_vip_start(self, vip_start, mgmtip, selfip_external):
        if not selfip_external and not vip_start:
            LOG.info('Skipping auto VIP generation.')
            return

        if selfip_external:
            if not isinstance(selfip_external, IPNetwork):
                selfip_external = IPNetwork(selfip_external)

            if selfip_external.prefixlen == 32:
                    LOG.info('Self IP external has no prefix. Assuming /16.')
                    selfip_external.prefixlen = 16

        if vip_start is None:
            # '1.1.1.1/24' -> '1.1.1.0/24'
            cidr = "{0.network}/{0.prefixlen}".format(mgmtip)
            host_id = mgmtip.ip.value - mgmtip.network.value
            subnet_index = SUBNET_MAP.get(cidr)

            if subnet_index is None:
                LOG.warning('The %s subnet was not found! '
                            'Skipping Virtual Servers.' % cidr)
                return

            # Start from 10.11.50.0 - 10.11.147.240 (planned for 10 subnets, 8 VIPs each)
            offset = 1 + 50 * 256 + DEFAULT_VIPS * (256 * subnet_index + host_id)

            vip_start = selfip_external.network + offset
        else:
            vip_start = IPAddress(vip_start)
        return vip_start

    def call(self, *args, **kwargs):
        ret = SCMD.ssh.generic(command=args[0], ifc=self.sshifc)

        if ret and ret.status:
            LOG.warn(ret)
        else:
            LOG.debug(ret)
        return ret

    def license(self, ctx, regkey):
        if ctx.status == 'NO LICENSE' and not regkey:
            raise Exception('The box needs to be relicensed first.'
                            'Provide --license <regkey>')

        # Status could be '' in some situations when the license is invalid.
        if regkey and (ctx.status in ['LICENSE INOPERATIVE', 'NO LICENSE', '']
                       or self.options.get('force_license')):
            LOG.info('Licensing...')
            self.call('SOAPLicenseClient --verbose --basekey %s' % regkey)
            # We need to re-set the modules based on the new license
            tokens = SCMD.ssh.parse_license(ifc=self.sshifc, tokens_only=True)
            ctx.modules = dict([(k[4:], v) for (k, v) in tokens.items()
                               if k.startswith('mod_')])

            ctx.features = dict([(k, v) for (k, v) in tokens.items()
                                if not k.startswith('mod_')])

            # Tomcat doesn't like the initial licensing through CLI
            if ctx.version.product.is_em:
                ret = self.call('bigstart restart tomcat')
        elif ctx.status in ['LICENSE EXPIRED', 'REACTIVATE LICENSE']:
            LOG.info('Re-Licensing...')
            ret = self.call('SOAPLicenseClient --verbose --basekey `grep '
                            '"Registration Key" /config/bigip.license|'
                            'cut -d: -f2`')
            LOG.debug("SOAPLicenseClient returned: %s", ret)

        else:
            LOG.info('Skipping licensing.')

    def load_default_config(self):
        ctx = self.context
        if self.can.tmsh(ctx.version):
            LOG.info('Importing default config...')
            self.call('tmsh load sys config default')
        else:
            LOG.info('Importing default config...')
            self.call('b import default')

        if ctx.version.product.is_bigiq:
            self.call(WIPE_STORAGE)

    def setup(self):
        provider = O()
        if not self.options.no_irack and not self.options.csv:
            LOG.info("Using data from iRack")
            provider = self.irack_provider(address=self.options.irack_address,
                                           username=self.options.irack_username,
                                           apikey=self.options.irack_apikey,
                                           mgmtip=self.address,
                                           timeout=self.options.timeout)
        elif self.options.csv:
            LOG.info("Using data from CSV: %s" % self.options.csv)
            provider = self.csv_provider(mgmtip=self.address)

        ctx = self.make_context()

        # System
        o = O()
        o.partitions = self.options.partitions
        o.nameservers = DNS_SERVERS if self.options.dns_servers is None else \
            self.options.dns_servers
        o.suffixes = DNS_SUFFIXES if self.options.dns_suffixes is None else \
            self.options.dns_suffixes
        o.ntpservers = NTP_SERVERS if self.options.ntp_servers is None else \
            self.options.ntp_servers
        o.smtpserver = 'mail.f5net.com'
        o.hostname = self.options.hostname or provider.get('hostname')
        o.timezone = self.options.timezone
        self.set_networking(o)
        self.set_provisioning(o)
        self.set_users(o)
        if provider.mgmtip and (o.mgmtip.ip != provider.mgmtip.ip or
                                o.mgmtip.cidr != provider.mgmtip.cidr):
            LOG.warning('Management address mismatch. iRack/CSV has {0} but found {1}. iRack/CSV will take precedence.'.format(provider.mgmtip, o.mgmtip))
            o.mgmtip = provider.mgmtip
        mgmtip = o.mgmtip

        if provider.gateway and o.gateway != provider.gateway:
            LOG.warning('Default gateway address mismatch. iRack/CSV has {0} but found {1}. iRack/CSV will take precedence.'.format(provider.gateway, o.gateway))
            o.gateway = provider.gateway
        tree = self.SystemConfig(self.context, **o).run()

        if self.options.clean:
            self.load_default_config()

        if not self.options.stdout:
            self.load(tree, ctx, func=lambda x: not isinstance(x, Partition))

        if not self.options.stdout:
            # XXX: Add any given DNS before attempting to relicense.
            # Licensing may need to resolve the license server hostname.
            if self.can.tmsh(ctx.version):
                self.call('tmsh modify sys dns name-servers add { %s }' % ' '.join(o.nameservers))
            self.license(ctx, self.options.license or provider and provider.licenses.reg_key[0])

        if self.options.clean:
            self.reset_trust()
            return

        # Network
        o = O()
        o.tree = tree
        self.set_vlans(o)
        o.selfips = {}
        selfip_internal = self.options.selfip_internal or provider and provider.selfip.internal
        selfip_external = self.options.selfip_external or provider and provider.selfip.external
        if selfip_internal:
            o.selfips.internal = [O(address=selfip_internal)]
            # o.selfips.internal.append(O(address=ip4to6(selfip_internal), name='int_6'))
            o.selfips.internal.append(O(address=ip4to6(selfip_internal)))

        if selfip_external:
            o.selfips.external = [O(address=selfip_external)]
            # o.selfips.external.append(O(address=ip4to6(selfip_external), name='ext_6'))
            o.selfips.external.append(O(address=ip4to6(selfip_external)))
        tree = self.NetworkConfig(self.context, **o).run()

        # LTM
        o = O()
        o.tree = tree
        o.nodes = self.options.node_count
        o.pools = self.options.pool_count
        o.members = self.options.pool_members
        o.vips = self.options.vip_count
        o.node1 = self.options.node_start
        o.vip1 = self.calculate_vip_start(self.options.vip_start, mgmtip,
                                          selfip_external)
        o.with_monitors = not self.options.no_mon
        tree = self.LTMConfig(self.context, **o).run()

        if self.options.stdout:
            self.dump(tree, ctx)
            return

        self.load(tree, ctx)
        self.reset_trust()
        self.ready_wait()
        self.save(ctx)
        self.ssh_key_exchange()
        self.ssl_signedcert_install(o.hostname)
        self.bigiq_special_selfip_handling(tree, ctx)

    def cleanup(self):
        self.sshifc.close()


def main(*args, **kwargs):
    import optparse
    # import sys

    class OptionWithDefault(optparse.Option):
        strREQUIRED = 'required'
        ATTRS = optparse.Option.ATTRS + [strREQUIRED]

        def __init__(self, *opts, **attrs):
            if attrs.get(self.strREQUIRED, False):
                attrs['help'] = '(Required) ' + attrs.get('help', "")
            optparse.Option.__init__(self, *opts, **attrs)

    class OptionParser(optparse.OptionParser):
        strREQUIRED = 'required'

        def __init__(self, **kwargs):
            kwargs['option_class'] = OptionWithDefault
            optparse.OptionParser.__init__(self, **kwargs)

        def check_values(self, values, args):
            for option in self.option_list:
                if hasattr(option, self.strREQUIRED) and option.required:
                    if not getattr(values, option.dest):
                        self.error("option %s is required" % (str(option)))
            return optparse.OptionParser.check_values(self, values, args)

    def _parser():
        usage = """%prog [options] <address>"""

        formatter = optparse.TitledHelpFormatter(max_help_position=30)
        p = OptionParser(usage=usage,
                         formatter=formatter,
                         version="Config Generator %s" % __version__,
                         )

        p.add_option("", "--partitions", metavar="NUMBER",
                     default=DEFAULT_PARTITIONS, type="int",
                     help="How many partitions. (default: %d)" % DEFAULT_PARTITIONS)
        p.add_option("", "--node-start", metavar="IP", type="string",
                     default=DEFAULT_NODE_START,
                     help="The start address for nodes. (default: %s)" % DEFAULT_NODE_START)
        p.add_option("-n", "--node-count", metavar="NUMBER",
                     default=DEFAULT_NODES, type="int",
                     help="How many nodes. (default: %d)" % DEFAULT_NODES)
        p.add_option("-o", "--pool-count", metavar="NUMBER",
                     default=DEFAULT_POOLS, type="int",
                     help="How many pools. (default: %d)" % DEFAULT_POOLS)
        p.add_option("", "--pool-members", metavar="NUMBER",
                     default=DEFAULT_MEMBERS, type="int",
                     help="How many pool members per pool. (default: %d)" % DEFAULT_MEMBERS)
        p.add_option("", "--vip-start", metavar="IP", type="string",
                     help="The start address for vips. (default: auto)")
        p.add_option("-v", "--vip-count", metavar="NUMBER",
                     default=DEFAULT_VIPS, type="int",
                     help="How many Virtual IPs. (default: %d)" % DEFAULT_VIPS)
        p.add_option("-u", "--username", metavar="STRING",
                     type="string", default=DEFAULT_ROOT_USERNAME,
                     help="SSH root username. (default: %s)" % DEFAULT_ROOT_USERNAME)
        p.add_option("-p", "--password", metavar="STRING",
                     type="string", default=DEFAULT_ROOT_PASSWORD,
                     help="SSH root Password. (default: %s)" % DEFAULT_ROOT_PASSWORD)

        p.add_option("", "--hostname", metavar="HOSTNAME",
                     type="string",
                     help="The device hostname")
        p.add_option("", "--mgmtip", metavar="IP/PREFIX",
                     type="string",
                     help="The device management address")
        p.add_option("", "--mgmtgw", metavar="IP",
                     type="string",
                     help="The device management gateway")
        p.add_option("", "--ssl-port", metavar="INTEGER", type="int", default=443,
                     help="SSL Port. (default: 443)")
        p.add_option("", "--ssh-port", metavar="INTEGER", type="int", default=22,
                     help="SSH Port. (default: 22)")
        p.add_option("", "--selfip-internal", metavar="IP[/PREFIX]",
                     type="string",
                     help="Self IP address for internal vlan.")
        p.add_option("", "--selfip-external", metavar="IP[/PREFIX]",
                     type="string",
                     help="Self IP address for external vlan.")
        p.add_option("", "--vlan-internal", metavar="KEY-VALUE PAIRS",
                     type="string",
                     help="Internal VLAN configuration. (e.g 'tag=1111 tagged=1.1 untagged=1.2')")
        p.add_option("", "--vlan-external", metavar="KEY-VALUE PAIRS",
                     type="string",
                     help="External VLAN configuration. (e.g 'tag=1112 tagged=1.1 untagged=1.2')")
        p.add_option("", "--trunks-lacp",
                     action="store_true",
                     help="Enable LACP on bonth internal and external trunks. (Clusters only)")
        p.add_option("", "--provision", metavar="MODULE:[LEVEL],[MODULE:LEVEL]",
                     type="string",
                     help="Provision module list")
        p.add_option("", "--license", metavar="REGKEY",
                     type="string",
                     help="Set the license")
        p.add_option("", "--force_license", action="store_true", default=False,
                     help="License using a provided reg key. (default: no)")
        p.add_option("", "--timezone", metavar="ZONE",
                     type="string",
                     help="Set the timezone. (e.g. 'America/Los Angeles')")
        p.add_option("", "--dns-server", metavar="IP", dest="dns_servers",
                     type="string", action="append",
                     help="DNS server (multiple OK)")
        p.add_option("", "--dns-suffix", metavar="FQDN", dest="dns_suffixes",
                     type="string", action="append",
                     help="DNS domain search suffix (multiple OK)")
        p.add_option("", "--ntp-server", metavar="FQDN", dest="ntp_servers",
                     type="string", action="append",
                     help="NTP server (multiple OK)")
        p.add_option("", "--clean",
                     action="store_true",
                     help="Clean vips, pools, nodes on the target")
        p.add_option("", "--verify",
                     action="store_true",
                     help="Verify configuration")

        p.add_option("", "--irack-address", metavar="HOSTNAME",
                     type="string", default="irack.mgmt.pdsea.f5net.com",
                     help="The iRack hostname or IP address")
        p.add_option("", "--irack-username", metavar="STRING",
                     type="string", default="guest",
                     help="Username used to authenticate with iRack.")
        p.add_option("", "--irack-apikey", metavar="STRING",
                     type="string", default="b8e977cd-9b99-413b-8c3f-8c4411941b8e",
                     help="API key used to authenticate with iRack")

        p.add_option("", "--no-mon",
                     action="store_true",
                     help="Don't set monitors for nodes and pool members. Useful for huge configs.")
        p.add_option("", "--no-sshkey",
                     action="store_true",
                     help="Don't exchange SSH keys.")
        p.add_option("", "--no-irack",
                     action="store_true",
                     help="Don't attempt to connect to iRack. Useful when network connectivity is not available.")
        p.add_option("", "--csv",
                     type="string", default="",
                     help="Specify the CSV file you want to use. Ex. /config/users/shared/my_file.csv")
        p.add_option("", "--timeout",
                     default=DEFAULT_TIMEOUT, type="int",
                     help="The SSH timeout. (default: %d)" % DEFAULT_TIMEOUT)
        p.add_option("", "--verbose",
                     action="store_true",
                     help="Debug messages")
        p.add_option("", "--stdout",
                     action="store_true",
                     help="Dump configuration to stdout")
        return p

    p = _parser()
    options, args = p.parse_args()

    if options.verbose:
        level = logging.DEBUG
    else:
        level = logging.INFO
        # Shut paramiko's mouth
        logging.getLogger('paramiko.transport').setLevel(logging.ERROR)
        logging.getLogger('f5test').setLevel(logging.ERROR)
        logging.getLogger('f5test.macros').setLevel(logging.INFO)

    LOG.setLevel(level)
    logging.basicConfig(level=level)

    if not args:
        p.print_version()
        p.print_help()
        sys.exit(2)  # @UndefinedVariable

    m = ConfigPlacer(options, address=args[0])
    m.run()

if __name__ == '__main__':
    main()
