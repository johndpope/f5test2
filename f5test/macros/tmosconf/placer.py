#!/usr/bin/env python
'''
Created on Apr 17, 2013

@author: jono
'''
from __future__ import absolute_import
from f5test.macros.base import Macro
from f5test.interfaces.ssh import SSHInterface
from f5test.interfaces.config import ConfigInterface
from f5test.interfaces.rest.irack import IrackInterface
from f5test.macros.tmosconf.scaffolding import Partition
from f5test.macros.tmosconf.base import (SystemConfig, NetworkConfig,
                                         LTMConfig)
import f5test.commands.shell as SCMD
from f5test.utils.net import ip4to6
from f5test.macros.webcert import WebCert
from f5test.macros.keyswap import KeySwap
from f5test.base import Options as O
from f5test.defaults import ROOT_USERNAME, ROOT_PASSWORD
from netaddr import IPAddress, IPNetwork
import logging
import re
import sys

__version__ = 2.0

DEFAULT_NODES = 10
DEFAULT_NODE_START = '10.10.0.50'
DEFAULT_POOLS = 60
DEFAULT_MEMBERS = 1
DEFAULT_VIPS = 8
DEFAULT_PARTITIONS = 0
DEFAULT_ROOT_PASSWORD = ROOT_PASSWORD
DEFAULT_TIMEOUT = 180
DEFAULT_SELF_PREFIX = 16
SCF_FILENAME = '/tmp/config.scf'
HEADER = """# Autogenerated by tmosconf %s\n\n""" % __version__
LOG = logging.getLogger(__name__)

# All known 172.27.XXX.0/24 subnets tangent to the VLAN1011.
# This is used for VS address allocation.
SUBNET_MAP = dict([(y, x) for x, y in enumerate(('172.27.27.0/24',
                                                 '172.27.58.0/24',
                                                 '172.27.62.0/24',
                                                 '172.27.63.0/24',
                                                 '172.27.65.0/24',
                                                 '172.27.90.0/24',
                                                 '172.27.91.0/24',
                                                 '172.27.92.0/24',
                                                 '172.27.93.0/24',
                                                 '172.27.94.0/24',
                                                 '172.27.95.0/24',
                                                 '172.27.96.0/24',
                                                 '172.27.97.0/24',
                                                 '172.27.59.0/24',
                                                 '172.27.11.0/24',
                                                 '172.27.29.0/24',
                                                 '10.144.2.0/24',
                                                 '172.27.98.0/24',
                                                 '172.27.76.0/24',
                                                 ))])


class ConfigPlacer(Macro):
    SystemConfig = SystemConfig
    NetworkConfig = NetworkConfig
    LTMConfig = LTMConfig

    def __init__(self, options, address=None, *args, **kwargs):
        self.context = O()
        self.options = O(options)

        self.options.setifnone('node_count', DEFAULT_NODES)
        self.options.setifnone('pool_count', DEFAULT_POOLS)
        self.options.setifnone('pool_members', DEFAULT_MEMBERS)
        self.options.setifnone('vip_count', DEFAULT_VIPS)
        self.options.setifnone('node_start', DEFAULT_NODE_START)
        self.options.setifnone('partitions', DEFAULT_PARTITIONS)
        self.options.setifnone('password', DEFAULT_ROOT_PASSWORD)
        self.options.setifnone('timeout', DEFAULT_TIMEOUT)

        if self.options.device:
            device = ConfigInterface().get_device(options.device)
            self.address = device.address
        else:
            self.address = address

        # can.* shortcuts to check for certain features based on the version
        self.can = O()
        self.can.tmsh = lambda v: (v.product.is_bigip and v >= 'bigip 11.0.0' or
                                   v.product.is_em and v >= 'em 2.0.0' or
                                   v.product.is_bigiq)
        self.can.provision = lambda v: (v.product.is_bigip and v >= 'bigip 10.0.1' or
                                        v.product.is_em and v >= 'em 2.0.0' or
                                        v.product.is_bigiq)
        self.can.lvm = lambda sshifc: not sshifc('/usr/lib/install/lvmtest').status

        self.has = O()
        self.has.asm = lambda s: bool(SCMD.tmsh.get_provision(ifc=s).asm)
        self.has.lvm = lambda s: not s('/usr/lib/install/lvmtest').status

        super(ConfigPlacer, self).__init__(*args, **kwargs)

    def irack_provider(self, address, username, apikey, mgmtip, timeout=120):
        """Get the static data for a device with a given mgmtip from iRack."""
        data = O()
        with IrackInterface(address=address,
                            timeout=timeout,
                            username=username,
                            password=apikey, proto='http') as irack:
            params = dict(address_set__address__in=mgmtip)
            # Locate the static bag for the F5Asset with mgmtip
            ret = irack.api.staticbag.filter(asset__type=1, **params)

            if ret.data.meta.total_count == 0:
                LOG.warning("No devices with mgmtip=%s found in iRack." % mgmtip)
                return {}
            if ret.data.meta.total_count > 1:
                raise ValueError("More than one device with mgmtip=%s found in iRack." % mgmtip)

            bag = ret.data.objects[0]
            bagid = bag['id']

            # Get the hostname
            ret = irack.api.staticsystem.filter(bag=bagid)
            assert ret.data.meta.total_count == 1, "No StaticSystem entries for bagid=%s" % bagid
            data.hostname = ret.data.objects[0].hostname

            # Get all reg_keys
            ret = irack.api.staticlicense.filter(bag=bagid)
            assert ret.data.meta.total_count >= 1, "No StaticLicense entries for bagid=%s" % bagid
            data.licenses = {}
            data.licenses.reg_key = [x.reg_key for x in ret.data.objects]

            # Get all VLAN -> self IPs pairs
            ret = irack.api.staticaddress.filter(bag=bagid, type=1)
            data.selfip = {}
            for o in ret.data.objects:
                vlan = o.vlan.split('/')[-1]
                # TODO: IPv6 support...someday?
                if IPAddress(o.address).version == 4 \
                   and not int(o.floating):
                    data.selfip[vlan] = IPNetwork("{0.address}/{0.netmask}".format(o))

            # Get all mgmt ips
            ret = irack.api.staticaddress.filter(bag=bagid, type=0)
            assert ret.data.meta.total_count >= 1, "No StaticAddress entries for bagid=%s" % bagid
            data.mgmtip = {}
            for o in ret.data.objects:
                if IPAddress(o.address).version == 4:
                    data.mgmtip = IPNetwork("{0.address}/{0.netmask}".format(o))

            # GW
            ret = irack.api.staticaddress.filter(bag=bagid, type=3)
            assert ret.data.meta.total_count >= 1, "No StaticAddress entries for bagid=%s" % bagid
            for o in ret.data.objects:
                if IPAddress(o.address).version == 4:
                    data.gateway = IPAddress(o.address)

        LOG.debug(data)
        return data

    def make_context(self):
        ctx = self.context
        version_data = SCMD.ssh.get_version(ifc=self.sshifc)
        ctx.version = version_data
        ctx.project = SCMD.ssh.parse_keyvalue_file('/VERSION',
                                                   ifc=self.sshifc).get('project')
        ctx.platform = SCMD.ssh.get_platform(ifc=self.sshifc)['platform']
        ctx.is_cluster = SCMD.ssh.is_cluster(ifc=self.sshifc)
        ctx.is_vcmp = ctx.platform == 'Z101'
        ctx.status = SCMD.ssh.GetPrompt(ifc=self.sshifc).run_wait(
                                  lambda x: x not in ('INOPERATIVE',),
                                  progress_cb=lambda x: 'Still inoperative...',
                                  timeout=self.options.timeout)

        if self.can.provision(ctx.version):
            ctx.provision = {}
            modules = SCMD.tmsh.get_provision(ifc=self.sshifc)
            for k, v in modules.iteritems():
                if v:
                    ctx.provision[k] = v['level']

        try:
            tokens = SCMD.ssh.parse_license(ifc=self.sshifc, tokens_only=True)
            ctx.modules = dict([(k[4:], v) for (k, v) in tokens.items()
                                           if k.startswith('mod_')])

            ctx.features = dict([(k, v) for (k, v) in tokens.items()
                                        if not k.startswith('mod_')])
        except SCMD.ssh.LicenseParsingError as e:
            ctx.modules = {}
            ctx.features = {}
            LOG.debug(e)
            LOG.warning('License file parsing failed. Harmless if this is a clean box.')

        LOG.info('Version: {0.product.to_tmos} {0.version} {0.build}'.format(ctx.version))
        LOG.info('Platform: %s', ctx.platform)
        LOG.info('Licensed modules: %s', ', '.join(sorted(ctx.modules)))
        if self.can.provision(ctx.version):
            LOG.info('Current provisioning: %s', ', '.join(sorted(ctx.provision)))
        return ctx

    def prep(self):
        self.sshifc = SSHInterface(address=self.address,
                                   password=self.options.password,
                                   timeout=self.options.timeout,
                                   port=self.options.ssh_port)
        self.sshifc.open()

    def set_networking(self, o):
        ctx = self.context
        if self.options.mgmtip:
            o.mgmtip = IPNetwork(self.options.mgmtip)
            if o.mgmtip.prefixlen == 32:
                o.mgmtip.prefixlen = 24
                LOG.warning('Assuming /24 to the management IP.')
        elif ctx.is_cluster:
            ret = SCMD.tmsh.list('sys cluster default', ifc=self.sshifc)
            o.mgmtip = IPNetwork(ret['sys cluster default']['address'])
            ret = SCMD.tmsh.list('sys management-route', ifc=self.sshifc)
            # Sometimes it's defined as "default" some other times it's "0.0.0.0"
            if ret:
                o.gateway = IPAddress(ret.values()[0]['gateway'])
        else:
            # Try to find the existing IP configuration on management interface.
            ret = self.sshifc("ethconfig --getcurrent")
            bits = ret.stdout.split()
            o.mgmtip = IPNetwork("{0[0]}/{0[1]}".format(bits))
            o.gateway = IPAddress(bits[2])

        # If None or IPAddress('0.0.0.0')
        if not o.gateway:
            o.gateway = IPAddress(self.options.mgmtgw) if self.options.mgmtgw \
                                                       else o.mgmtip.broadcast - 1

        # Preserve the DHCP flag for the management interface
        if self.can.tmsh(ctx.version):
            ret = SCMD.tmsh.list('sys db dhclient.mgmt', ifc=self.sshifc)
            o.dhcp = ret['sys db dhclient.mgmt']['value'] == 'enable'

    def set_provisioning(self, o):
        ctx = self.context
        if not self.can.provision(ctx.version):
            LOG.info('Provision not supported on the target')
            return

        o.provision = {}
        provision = []
        if self.options.get('provision'):
            for prov in self.options['provision'].split(','):
                if prov:
                    bits = prov.lower().split(':', 1)
                    if len(bits) > 1:
                        module, level = bits
                        assert level in ('minimum', 'nominal', 'dedicated')
                    else:
                        module = bits[0].strip()
                        level = 'nominal' if module == 'ltm' else 'minimum'
                    provision.append((module, level))

        if provision:
            v = ctx.version
            for module, level in provision:
                if module == 'afm' and not (v.product.is_bigip and v >= 'bigip 11.3.0'):
                    LOG.warning('AFM cannot be provisioned on this target.')
                    continue
                o.provision[module] = level
        else:
            # Preserve provisioning.
            modules = SCMD.tmsh.get_provision(ifc=self.sshifc)
            for module, level_kv in modules.iteritems():
                if level_kv:
                    level = level_kv['level']
                    o.provision[module] = level

    def set_users(self, o):
        ctx = self.context
        v = ctx.version
        o.users = {}

        o.users.a = 'admin'
        if v.product.is_bigip or v.product.is_em:
            o.users.g = 'guest'
            o.users.o = 'operator'
            o.users.ae = 'application-editor'
            o.users.m = 'manager'
            o.users.um = 'user-manager'
            o.users.ra = 'resource-admin'

        if v.product.is_bigip and v >= 'bigip 11.3.0':
            o.users.cm = 'certificate-manager'
            o.users.im = 'irule-manager'
            o.users.au = 'auditor'
            o.users.asa = 'web-application-security-administrator'
            o.users.ase = 'web-application-security-editor'
            o.users.fm = 'firewall-manager'

        if v.product.is_bigiq:
            o.users.g = 'guest'
            o.users.fw = 'firewall-manager'

    def set_vlans(self, o):
        ctx = self.context
        lacp = self.options.trunks_lacp

        if ctx.platform.startswith('A'):
            o.trunks = {}
            eth1 = 'internal'  # Trunk names
            eth2 = 'external'
        else:
            eth1 = '1.1'
            eth2 = '1.2'

        if ctx.platform == 'A100':
            o.trunks.internal = O(interfaces=['1/2.1', '2/2.1', '3/2.1', '4/2.1'], lacp=lacp)
            o.trunks.external = O(interfaces=['1/2.2', '2/2.2', '3/2.2', '4/2.2'], lacp=lacp)
        elif ctx.platform in ('A107', 'A109', 'A111'):
            o.trunks.internal = O(interfaces=['1/1.1', '2/1.1', '3/1.1', '4/1.1'], lacp=lacp)
            o.trunks.external = O(interfaces=['1/1.2', '2/1.2', '3/1.2', '4/1.2'], lacp=lacp)
        elif ctx.platform == 'A108':
            o.trunks.internal = O(interfaces=['1/1.1', '2/1.1', '3/1.1', '4/1.1', '5/1.1', '6/1.1', '7/1.1', '8/1.1'], lacp=lacp)
            o.trunks.external = O(interfaces=['1/1.2', '2/1.2', '3/1.2', '4/1.2', '5/1.2', '6/1.2', '7/1.2', '8/1.2'], lacp=lacp)

        def parse_vlan_options(kind):
            specs = O(tagged=[], untagged=[])
            if kind == 'internal':
                tags = self.options.vlan_internal
                if not tags:
                    specs.untagged.append(eth1)
            if kind == 'external':
                tags = self.options.vlan_external
                if not tags:
                    specs.untagged.append(eth2)

            if tags:
                for tag in re.split('\s+', tags):
                    key, value = tag.split('=')
                    if key == 'tag':
                        specs.tag = value
                    else:
                        specs[key].append(value)
            return specs

        o.vlans = {}
        o.vlans.internal = O(**parse_vlan_options('internal'))
        o.vlans.external = O(**parse_vlan_options('external'))

#     def fix_cmi(self):
#         """
#         The main goal of this method is to empty all device groups, otherwise
#         the config load will fail. There should be a better way of doing this.
#         """
#         ctx = self.context
#         if self.can.tmsh(ctx.version):
#             LOG.debug('Emptying CM device groups...')
#             ret = SCMD.tmsh.list('cm device-group', ifc=self.sshifc)
#             for key, value in ret.iteritems():
#                 devices = value.get('devices')
#                 if devices:
#                     ret = self.sshifc('tmsh modify %s devices delete { %s }' %
#                                       (key, ' '.join(devices.keys())))
#                     if ret.status:
#                         LOG.warning(ret)

    def dump(self, tree, ctx, func=None):
        f = sys.stdout  # @UndefinedVariable
        LOG.info('Rendering configuration file...')
        f.write(HEADER)
        tree.render(stream=f, func=func)

    def load(self, tree, ctx, func=None):
        with self.sshifc.api.sftp().open(SCF_FILENAME, 'w') as f:
            LOG.info('Rendering configuration file...')
            f.write(HEADER)
            tree.render(stream=f, func=func)

        if self.can.tmsh(ctx.version):
            if self.options.verify:
                LOG.info('Verifying configuration...')
                ret = self.sshifc('tmsh load sys config file %s verify' % SCF_FILENAME)
                LOG.info(ret.stdout)
            else:
                LOG.info('Loading configuration...')
                SCMD.ssh.generic('tmsh load sys config file %s' % SCF_FILENAME, ifc=self.sshifc)
        else:
            LOG.info('Loading configuration...')
            SCMD.ssh.generic('b import  %s' % SCF_FILENAME, ifc=self.sshifc)

    def save(self, ctx):
        LOG.info('Saving configuration...')
        if self.can.tmsh(ctx.version):
            SCMD.ssh.generic('tmsh save sys config partitions all', ifc=self.sshifc)
        else:
            SCMD.ssh.generic('b save all', ifc=self.sshifc)

    def reset_trust(self):
        ctx = self.context
        if self.can.tmsh(ctx.version):
            LOG.info('Resetting trust...')
            SCMD.ssh.Generic('tmsh delete cm trust-domain all', ifc=self.sshifc).\
                run_wait(lambda x: x.status == 0,
                         progress_cb=lambda x: 'delete trust-domain retry...',
                         timeout=self.options.timeout)

    def ready_wait(self):
        ctx = self.context
        if self.options.get('dry_run'):
            return

        LOG.info('Waiting for reconfiguration...')
        timeout = self.options.timeout
        SCMD.ssh.FileExists('/var/run/mprov.pid', ifc=self.sshifc).run_wait(lambda x: x is False,
                                             progress_cb=lambda x: 'mprov still running...',
                                             timeout=timeout)
        if (self.can.provision(ctx.version) and self.has.asm(self.sshifc) and
            self.has.lvm(self.sshifc)):
            SCMD.ssh.FileExists('/var/lib/mysql/.moved.to.asmdbvol',
                                ifc=self.sshifc).run_wait(lambda x: x,
                                                 progress_cb=lambda x: 'ASWADB still not there...',
                                                 timeout=timeout)
        # Wait for ASM config server to come up.
        if self.can.provision(ctx.version) and self.has.asm(self.sshifc):
            LOG.info('Waiting for ASM config server to come up...')
            SCMD.ssh.Generic(r'netstat -anp|grep "9781.*0\.0\.0\.0:\*.*LISTEN"|wc -l',
                            ifc=self.sshifc).run_wait(lambda x: int(x.stdout),
                                                   progress_cb=lambda x: 'ASM cfg server not up...',
                                                   timeout=timeout)

        LOG.info('Waiting for Active prompt...')
        s = SCMD.ssh.GetPrompt(ifc=self.sshifc).run_wait(lambda x: x in ('Active',
                                                                     'Standby',
                                                                     'ForcedOffline',
                                                                     'RESTART DAEMONS',
                                                                     'REBOOT REQUIRED'),
                                                  progress_cb=lambda x: 'Still not active...',
                                                  timeout=timeout)

        if s == 'RESTART DAEMONS':
            LOG.info('Restarting daemons...')
            self.call('bigstart restart')
            SCMD.ssh.GetPrompt(ifc=self.sshifc).run_wait(lambda x: x in ('Active',
                                                                     'Standby',
                                                                     'ForcedOffline'),
                                                      progress_cb=lambda x: 'Still not active...',
                                                      timeout=timeout)
        elif s == 'REBOOT REQUIRED':
            LOG.warn('A manual reboot is required.')

        if SCMD.ssh.file_exists('/var/run/grub.conf.lock', ifc=self.sshifc):
            self.ssh.api.remove('/var/run/grub.conf.lock')

    def ssh_key_exchange(self):
        if self.options.get('no_sshkey'):
            return

        o = O()
        o.password = self.options.password
        cs = KeySwap(o, address=self.address)
        cs.run()

    def ssl_signedcert_install(self, hostname):
        o = O()
        o.admin_username = 'a'
        o.root_username = ROOT_USERNAME
        o.ssh_port = self.options.ssh_port
        o.ssl_port = self.options.ssl_port
        o.verbose = self.options.verbose
        o.timeout = self.options.timeout
        LOG.info('Pushing the key/certificate pair')

        # The special a:a admin user is used here. It should be included in the
        # remote_config yaml config in the users.administrator section.
        o.admin_password = 'a'
        o.root_password = self.options.password

        o.alias = [hostname]
        cs = WebCert(o, address=self.address)
        cs.run()

    def calculate_vip_start(self, vip_start, mgmtip, selfip_external):
        if not isinstance(selfip_external, IPNetwork):
            selfip_external = IPNetwork(selfip_external)

        if selfip_external.prefixlen == 32:
                LOG.info('Self IP external has no prefix. Assuming /16.')
                selfip_external.prefixlen = 16

        if vip_start is None:
            # '1.1.1.1/24' -> '1.1.1.0/24'
            cidr = "{0.network}/{0.prefixlen}".format(mgmtip)
            host_id = mgmtip.ip.value - mgmtip.network.value
            subnet_index = SUBNET_MAP.get(cidr)

            if subnet_index is None:
                raise ValueError('The %s subnet was not found. Please add it to SUBNET_MAP list!' %
                                 cidr)

            # Start from 10.11.50.0 - 10.11.147.240 (planned for 10 subnets, 8 VIPs each)
            offset = 1 + 50 * 256 + DEFAULT_VIPS * (256 * subnet_index + host_id)

            vip_start = selfip_external.network + offset
        else:
            vip_start = IPAddress(vip_start)
        return vip_start

    def call(self, *args, **kwargs):
        ret = SCMD.ssh.generic(command=args[0], ifc=self.sshifc)

        if ret and ret.status:
            LOG.warn(ret)
        else:
            LOG.debug(ret)
        return ret

    def license(self, ctx, regkey):
        if ctx.status == 'NO LICENSE' and not regkey:
            raise Exception('The box needs to be relicensed first.'
                            'Provide --license <regkey>')

        # Status could be '' in some situations when the license is invalid.
        if regkey and \
           ctx.status in ['LICENSE INOPERATIVE', 'NO LICENSE', '']:
            LOG.info('Licensing...')
            self.call('SOAPLicenseClient --verbose --basekey %s' % regkey)
            # We need to re-set the modules based on the new license
            tokens = SCMD.ssh.parse_license(ifc=self.sshifc, tokens_only=True)
            ctx.modules = dict([(k[4:], v) for (k, v) in tokens.items()
                                           if k.startswith('mod_')])

            ctx.features = dict([(k, v) for (k, v) in tokens.items()
                                        if not k.startswith('mod_')])

            # Tomcat doesn't like the initial licensing through CLI
            if ctx.version.product.is_em:
                ret = self.call('bigstart restart tomcat')
        elif ctx.status in ['LICENSE EXPIRED', 'REACTIVATE LICENSE']:
            LOG.info('Re-Licensing...')
            ret = self.call('SOAPLicenseClient --verbose --basekey `grep '
                             '"Registration Key" /config/bigip.license|'
                             'cut -d: -f2`')
            LOG.debug("SOAPLicenseClient returned: %s", ret)

        else:
            LOG.info('Skipping licensing.')

    def load_default_config(self):
        ctx = self.context
        if self.can.tmsh(ctx.version):
            LOG.info('Importing default config...')
            self.call('tmsh load sys config default')
        else:
            LOG.info('Importing default config...')
            self.call('b import default')

    def setup(self):
        irack = self.irack_provider(address=self.options.irack_address,
                                    username=self.options.irack_username,
                                    apikey=self.options.irack_apikey,
                                    mgmtip=self.address,
                                    timeout=self.options.timeout)
        ctx = self.make_context()
        if not self.options.stdout:
            self.license(ctx, self.options.license or irack.licenses.reg_key[0])

        # System
        o = O()
        o.partitions = self.options.partitions
        o.nameservers = ['172.27.1.1']
        o.suffixes = ['mgmt.pdsea.f5net.com', 'f5net.com']
        o.ntpservers = ['ntp.f5net.com']
        o.smtpserver = 'mail.f5net.com'
        o.hostname = self.options.hostname or irack.get('hostname')
        o.timezone = self.options.timezone
        self.set_networking(o)
        self.set_provisioning(o)
        self.set_users(o)
        mgmtip = o.mgmtip
        tree = self.SystemConfig(self.context, **o).run()

        if self.options.clean:
            self.load_default_config()

        if not self.options.stdout:
            self.load(tree, ctx, func=lambda x: not isinstance(x, Partition))

        if self.options.clean:
            self.reset_trust()
            return

        # Network
        o = O()
        o.tree = tree
        self.set_vlans(o)
        o.selfips = {}
        selfip_internal = self.options.selfip_internal or irack.selfip.internal
        selfip_external = self.options.selfip_external or irack.selfip.external
        o.selfips.internal = [O(address=selfip_internal)]
        o.selfips.external = [O(address=selfip_external)]
        #o.selfips.internal.append(O(address=ip4to6(selfip_internal), name='int_6'))
        #o.selfips.external.append(O(address=ip4to6(selfip_external), name='ext_6'))
        o.selfips.internal.append(O(address=ip4to6(selfip_internal)))
        o.selfips.external.append(O(address=ip4to6(selfip_external)))
        tree = self.NetworkConfig(self.context, **o).run()

        # LTM
        o = O()
        o.tree = tree
        o.nodes = self.options.node_count
        o.pools = self.options.pool_count
        o.members = self.options.pool_members
        o.vips = self.options.vip_count
        o.node1 = self.options.node_start
        o.vip1 = self.calculate_vip_start(self.options.vip_start, mgmtip,
                                          selfip_external)
        o.with_monitors = not self.options.no_mon
        tree = self.LTMConfig(self.context, **o).run()

        if self.options.stdout:
            self.dump(tree, ctx)
            return

        self.load(tree, ctx)
        self.reset_trust()
        self.ready_wait()
        self.save(ctx)
        self.ssh_key_exchange()
        self.ssl_signedcert_install(o.hostname)

    def cleanup(self):
        self.sshifc.close()


def main(*args, **kwargs):
    import optparse
    #import sys

    class OptionWithDefault(optparse.Option):
        strREQUIRED = 'required'
        ATTRS = optparse.Option.ATTRS + [strREQUIRED]

        def __init__(self, *opts, **attrs):
            if attrs.get(self.strREQUIRED, False):
                attrs['help'] = '(Required) ' + attrs.get('help', "")
            optparse.Option.__init__(self, *opts, **attrs)

    class OptionParser(optparse.OptionParser):
        strREQUIRED = 'required'

        def __init__(self, **kwargs):
            kwargs['option_class'] = OptionWithDefault
            optparse.OptionParser.__init__(self, **kwargs)

        def check_values(self, values, args):
            for option in self.option_list:
                if hasattr(option, self.strREQUIRED) and option.required:
                    if not getattr(values, option.dest):
                        self.error("option %s is required" % (str(option)))
            return optparse.OptionParser.check_values(self, values, args)

    def _parser():
        usage = """%prog [options] <address>"""

        formatter = optparse.TitledHelpFormatter(max_help_position=30)
        p = OptionParser(
                usage=usage,
                formatter=formatter,
                version="Config Generator %s" % __version__,
        )

        p.add_option("", "--partitions", metavar="NUMBER",
                     default=DEFAULT_PARTITIONS, type="int",
                     help="How many partitions. (default: %d)" % DEFAULT_PARTITIONS)
        p.add_option("", "--node-start", metavar="IP", type="string",
                     default=DEFAULT_NODE_START,
                     help="The start address for nodes. (default: %s)" % DEFAULT_NODE_START)
        p.add_option("-n", "--node-count", metavar="NUMBER",
                     default=DEFAULT_NODES, type="int",
                     help="How many nodes. (default: %d)" % DEFAULT_NODES)
        p.add_option("-o", "--pool-count", metavar="NUMBER",
                     default=DEFAULT_POOLS, type="int",
                     help="How many pools. (default: %d)" % DEFAULT_POOLS)
        p.add_option("", "--pool-members", metavar="NUMBER",
                     default=DEFAULT_MEMBERS, type="int",
                     help="How many pool members per pool. (default: %d)" % DEFAULT_MEMBERS)
        p.add_option("", "--vip-start", metavar="IP", type="string",
                     help="The start address for vips. (default: auto)")
        p.add_option("-v", "--vip-count", metavar="NUMBER",
                     default=DEFAULT_VIPS, type="int",
                     help="How many Virtual IPs. (default: %d)" % DEFAULT_VIPS)
        p.add_option("-p", "--password", metavar="STRING",
                     type="string", default=DEFAULT_ROOT_PASSWORD,
                     help="SSH root Password. (default: %s)" % DEFAULT_ROOT_PASSWORD)

        p.add_option("", "--hostname", metavar="HOSTNAME",
                     type="string",
                     help="The device hostname")
        p.add_option("", "--mgmtip", metavar="IP/PREFIX",
                     type="string",
                     help="The device management address")
        p.add_option("", "--mgmtgw", metavar="IP",
                     type="string",
                     help="The device management gateway")
        p.add_option("", "--ssl-port", metavar="INTEGER", type="int", default=443,
                     help="SSL Port. (default: 443)")
        p.add_option("", "--ssh-port", metavar="INTEGER", type="int", default=22,
                     help="SSH Port. (default: 22)")
        p.add_option("", "--selfip-internal", metavar="IP[/PREFIX]",
                     type="string",
                     help="Self IP address for internal vlan.")
        p.add_option("", "--selfip-external", metavar="IP[/PREFIX]",
                     type="string",
                     help="Self IP address for external vlan.")
        p.add_option("", "--vlan-internal", metavar="KEY-VALUE PAIRS",
                     type="string",
                     help="Internal VLAN configuration. (e.g 'tag=1111 tagged=1.1 untagged=1.2')")
        p.add_option("", "--vlan-external", metavar="KEY-VALUE PAIRS",
                     type="string",
                     help="External VLAN configuration. (e.g 'tag=1112 tagged=1.1 untagged=1.2')")
        p.add_option("", "--trunks-lacp",
                     action="store_true",
                     help="Enable LACP on bonth internal and external trunks. (Clusters only)")
        p.add_option("", "--provision", metavar="MODULE:[LEVEL],[MODULE:LEVEL]",
                     type="string",
                     help="Provision module list")
        p.add_option("", "--license", metavar="REGKEY",
                     type="string",
                     help="Set the license")
        p.add_option("", "--timezone", metavar="ZONE",
                     type="string",
                     help="Set the timezone. (e.g. 'America/Los Angeles')")
        p.add_option("", "--clean",
                     action="store_true",
                     help="Clean vips, pools, nodes on the target")
        p.add_option("", "--verify",
                     action="store_true",
                     help="Verify configuration")

        p.add_option("", "--irack-address", metavar="HOSTNAME",
                     type="string", default="irack.mgmt.pdsea.f5net.com",
                     help="The iRack hostname or IP address")
        p.add_option("", "--irack-username", metavar="STRING",
                     type="string", default="guest",
                     help="Username used to authenticate with iRack.")
        p.add_option("", "--irack-apikey", metavar="STRING",
                     type="string", default="b8e977cd-9b99-413b-8c3f-8c4411941b8e",
                     help="API key used to authenticate with iRack")

        p.add_option("", "--no-mon",
                     action="store_true",
                     help="Don't set monitors for nodes and pool members. Useful for huge configs.")
        p.add_option("", "--no-sshkey",
                     action="store_true",
                     help="Don't exchange SSH keys.")
        p.add_option("", "--timeout",
                     default=DEFAULT_TIMEOUT, type="int",
                     help="The SSH timeout. (default: %d)" % DEFAULT_TIMEOUT)
        p.add_option("", "--verbose",
                     action="store_true",
                     help="Debug messages")
        p.add_option("", "--stdout",
                     action="store_true",
                     help="Dump configuration to stdout")
        return p

    p = _parser()
    options, args = p.parse_args()

    if options.verbose:
        level = logging.DEBUG
    else:
        level = logging.INFO
        # Shut paramiko's mouth
        logging.getLogger('paramiko.transport').setLevel(logging.ERROR)
        logging.getLogger('f5test').setLevel(logging.ERROR)
        logging.getLogger('f5test.macros').setLevel(logging.INFO)

    LOG.setLevel(level)
    logging.basicConfig(level=level)

    if not args:
        p.print_version()
        p.print_help()
        sys.exit(2)  # @UndefinedVariable

    m = ConfigPlacer(options, address=args[0])
    m.run()

if __name__ == '__main__':
    main()
